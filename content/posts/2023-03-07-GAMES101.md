---
title: GAMES101 Lecture Notes
author: Xiao Fan
date: 2023-03-07
categories: [lecture notes]
tags: [Computer Graphics]
math: true
mermaid: true
typora-root-url: ../../assets
image: /img/posts/2023-03-07-GAMES101/games101.png
featuredImagePreview: /img/posts/2023-03-07-GAMES101/games101.png
---

[GAMES101](https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html)现代计算机图形学入门课程笔记

## 第二章 线性代数

### 叉乘

叉乘对于右手系来说使用右手螺旋定则。

笛卡尔坐标系下：


$$
\vec{a} \times \vec{b} = \begin{pmatrix} y_az_b-y_bz_a \cr z_ax_b - z_bx_a \cr x_ay_b - y_ax_b \end{pmatrix}
$$

矩阵写法：

$$
\vec{a} \times \vec{b} = A * b = \begin{pmatrix}0 & -z_a & y_a \cr z_a & 0 & -x_a \cr -y_a & x_a & 0\end{pmatrix}
$$

$A$叫做$\vec{a}$的<font color="red">伴随矩阵</font>

## 第三章 变换

### 齐次坐标

齐次坐标引入是为了线性表示仿射变换（线性变换+平移变换）

2D点的表示：$(x, y, 1)^T$

2D向量的表示：$(x, y, 0)^T$

### 2D变换

+ **缩放**
  $$
  \textbf{S}(s_x, s_y) = \begin{pmatrix}s_x & 0 & 0 \cr 0 & s_y & 0 \cr 0 & 0 & 1\end{pmatrix}
  $$
  
+ **旋转**
  
  注意$\alpha$为正表示逆时针
  $$
  \textbf{R}(\alpha) = \begin{pmatrix}\cos\alpha & -\sin\alpha & 0 \cr \sin\alpha & \cos\alpha & 0 \cr 0 & 0 & 1 \end{pmatrix}
  $$
  
+ **平移**
  $$
  \textbf{T}(t_x, t_y) = \begin{pmatrix}1 & 0 & t_x \cr 0 & 1 & t_y \cr 0 & 0 & 1\end{pmatrix}
  $$

### 3D变换

变换矩阵

$$
\begin{pmatrix}x' \cr y' \cr z'\end{pmatrix} = \begin{pmatrix}a & b & c & t_x \cr d & e & f & t_y \cr g & h & i & t_z \cr 0 & 0 & 0 & 1\end{pmatrix} \cdot \begin{pmatrix}x \cr y \cr z\end{pmatrix}
$$

先应用线性变换再应用平移


## 第四章 变换-2

### 正交矩阵

Transform matrix $\textbf{T}$是正交矩阵，则

$$
\textbf{T}^{-1} = \textbf{T}^T
$$


### 3D旋转变换

+ **旋转变换矩阵**
  
  + 绕x轴旋转
    $$
    \mathbf{R}_x(\alpha)=\left(\begin{array}{cccc}
    1 & 0 & 0 & 0 \cr
    0 & \cos \alpha & -\sin \alpha & 0 \cr
    0 & \sin \alpha & \cos \alpha & 0 \cr
    0 & 0 & 0 & 1
    \end{array}\right)
    $$
  
  + 绕y轴旋转
    $$
    \mathbf{R}_y(\alpha)=\left(\begin{array}{cccc}
    \cos \alpha & 0 & \sin \alpha & 0 \cr
    0 & 1 & 0 & 0 \cr
    -\sin \alpha & 0 & \cos \alpha & 0 \cr
    0 & 0 & 0 & 1
    \end{array}\right)
    $$
    
  + 绕z轴旋转
    $$
    \mathbf{R}_z(\alpha)=\left(\begin{array}{cccc}
    \cos \alpha & -\sin \alpha & 0 & 0 \cr
    \sin \alpha & \cos \alpha & 0 & 0 \cr
    0 & 0 & 1 & 0 \cr
    0 & 0 & 0 & 1
    \end{array}\right)
    $$
    
  
+ **欧拉角**
  $$
  \textbf{R}_{xyz}(\alpha, \beta, \gamma) = \textbf{R}_x(\alpha)\textbf{R}_y(\beta)\textbf{R}_z(\gamma)
  $$

+ **Rodigues旋转公式**

  绕着任意一个轴$\textbf{n}$旋转$\alpha$角度的变换为

  $$
  \textbf{R}(n, \alpha) = \cos(\alpha)\textbf{I} + (1 - \cos(\alpha))\textbf{n}\textbf{n}^T + \sin(\alpha)\underbrace{\begin{pmatrix}0 & -n_z & n_y \cr n_z & 0 & -n_x \cr -n_y & n_x & 0\end{pmatrix}}_{\textbf{N}, \text{dual matrix of n}}
  $$



### 视角变换(View Transform)

视角变换，包括View/camera transform和projection transform，与model transform合称**MVP**变换。
![image-20230307231128078](/img/posts/2023-03-07-GAMES101/image-20230307231128078.png)
默认情况下相机朝向-z轴, y轴朝上。我们需要将$\vec{e}$首先平移到圆点，然后将$\hat{g}$指向-z，$\hat{t}$指向y轴，$\hat{g}\times\hat{t}$指向x轴。

考虑逆变换，即x轴正方向旋转至$\hat{g}\times\hat{t}$，y轴正方向旋转至$\hat{t}$，z轴负方向旋转至$\hat{g}$。我们可以轻易得到该变换的旋转矩阵为


$$
R_{view}^{-1} = \begin{bmatrix}x_{\hat{g}\times\hat{t}} & x_{t} & x_{-g} & 0 \cr y_{\hat{g} \times \hat{t}} & y_t & y_{-g} & 0 \cr z_{\hat{g} \times \hat{t}} & z_t & z_{-g} & 0 \cr 0 & 0 & 0 & 1\end{bmatrix}
$$


因此原本的旋转矩阵应该为该矩阵的逆，由于旋转矩阵是正交阵，因此转置即可。


$$
R_{view} = \begin{bmatrix}x_{\hat{g}\times\hat{t}} & y_{\hat{g} \times \hat{t}} & z_{\hat{g} \times \hat{t}}  & 0 \cr x_{t} & y_t & z_t & 0 \cr x_{-g} & y_{-g} & z_{-g} & 0 \cr 0 & 0 & 0 & 1\end{bmatrix}
$$

### 投影变换(Project Transform)

#### 正交投影(Orthographic Projection)

![image-20230309184417051](/img/posts/2023-03-07-GAMES101/image-20230309184417051.png)

正交投影没有近大远小的效果。直接将$[l, r] \times [b, t] \times [f, n]$的盒式可见空间投影到$[-1, 1]$的标准立方体中。

![image-20230308235145849](/img/posts/2023-03-07-GAMES101/image-20230308235145849.png)

先将立方体中心平移到原点，再进行缩放变换，使得边界为$[-1, 1]$。


$$
M_{\text {ortho }}=\left[\begin{array}{cccc}
\frac{2}{r-l} & 0 & 0 & 0 \cr
0 & \frac{2}{t-b} & 0 & 0 \cr
0 & 0 & \frac{2}{n-f} & 0 \cr
0 & 0 & 0 & 1
\end{array}\right]\left[\begin{array}{cccc}
1 & 0 & 0 & -\frac{r+l}{2} \cr
0 & 1 & 0 & -\frac{t+h}{2} \cr
0 & 0 & 1 & -\frac{n+f}{2} \cr
0 & 0 & 0 & 1
\end{array}\right]
$$

#### 透视投影

![image-20230309184320243](/img/posts/2023-03-07-GAMES101/image-20230309184320243.png)

透视投影考虑到了近大远小的效果，模拟人类眼睛看到世界的过程。透视投影的视体(Viewing frustum)类似于一个锥台。我们需要将这个方平截头体“压缩”为一个立方体，然后对这个立方体进行正交投影变换即可。

“压缩”这个锥台是需要保证n面不变，f面映射到和n面相同的大小。

对于n面和f面中间所有的点$(x, y, z)$来说，可以用相似三角形求得$x'$和$y'$的值为$x'=\frac{n}{z}x$, $y'=\frac{n}{z}y$，如下图所示。

![image-20230309204121286](/img/posts/2023-03-07-GAMES101/image-20230309204121286.png)

但是要注意，$z'$的大小目前是未知的。

因此我们可以得出以下关系：


$$
M_{\text {persp } \rightarrow \text { ortho }}^{(4 \times 4)}\left(\begin{array}{l}
x \cr
y \cr
z \cr
1
\end{array}\right)=\left(\begin{array}{c}
n x \cr
n y \cr
\text { unknown } \cr
z
\end{array}\right)
$$



$$
M_{\text {persp } \rightarrow \text { ortho }}=\left(\begin{array}{cccc}
n & 0 & 0 & 0 \cr
0 & n & 0 & 0 \cr
? & ? & ? & ? \cr
0 & 0 & 1 & 0
\end{array}\right)
$$


由于当在n平面上所有的点都会保持不变，因此


$$
M_{\text {persp } \rightarrow \text { ortho }}^{(4 \times 4)} \left(\begin{array}{c}
x \cr
y \cr
n \cr
1
\end{array}\right)=\left(\begin{array}{c}
n x \cr
n y \cr
n^2 \cr
n
\end{array}\right)
$$


同时在f平面上，$(0, 0, f)$在变换后应当保持不变，因此


$$
M_{\text {persp } \rightarrow \text { ortho }}^{(4 \times 4)} \left(\begin{array}{c}
0 \cr
0 \cr
f \cr
1
\end{array}\right)=\left(\begin{array}{c}
0 \cr
0 \cr
f^2 \cr
f
\end{array}\right)
$$


根据这两个性质，可以求解得到


$$
M_{\text {persp } \rightarrow \text { ortho }}=\left(\begin{array}{cccc}
n & 0 & 0 & 0 \cr
0 & n & 0 & 0 \cr
0 & 0 & n + f & -nf \cr
0 & 0 & 1 & 0
\end{array}\right)
$$


因此最终的透视投影变换为


$$
M_{\text {persp }}=M_{\text {ortho }} M_{\text {persp } \rightarrow \text { ortho }} = \begin{pmatrix}\begin{array}{cccc}
\frac{2n}{r-l} & 0 & 0 & -\frac{r-l}{r+l} \cr
0 & \frac{2n}{t-b} & 0 & -\frac{t-b}{t+b} \cr
0 & 0 & \frac{f+n}{n-f} & \frac{2fn}{n-f} \cr
0 & 0 & -1 & 0
\end{array}\end{pmatrix}
$$


### 视角(Field of View)和长宽比(Aspect Ratio)

![image-20230309213311018](/img/posts/2023-03-07-GAMES101/image-20230309213311018.png)

fovY是从摄像机焦点到n平面的t和b线段中点所形成的夹角。长宽比为长/宽。

![image-20230309213544066](/img/posts/2023-03-07-GAMES101/image-20230309213544066.png)

因此我们可以得到


$$
\begin{aligned}
\tan \frac{f o v Y}{2} & =\frac{t}{|n|} \cr
\text { aspect } & =\frac{r}{t}
\end{aligned}
$$



## 第五章 三角形的光栅化

### 视口变换

MVP变换的作用是把所有的物体都放在$[-1, 1]^3$的空间中，一旦拥有了这个空间，我们需要进行光栅化以将其显示在屏幕上。

屏幕空间：由像素的二维矩阵组成

![image-20230419220511056](/img/posts/2023-03-07-GAMES101/image-20230419220511056.png)

首先不管z，我们先将$[-1,1]^2$变换到$[0, width] \times [0, height]$的二维平面上，这叫做视口变换(viewport transform)


$$
M_{\text {viewport }}=\left(\begin{array}{cccc}
\frac{\text { width }}{2} & 0 & 0 & \frac{\text { width }}{2} \cr
0 & \frac{\text { height }}{2} & 0 & \frac{\text { height }}{2} \cr
0 & 0 & 1 & 0 \cr
0 & 0 & 0 & 1
\end{array}\right)
$$


### 光栅化2D采样

得到视口变换后，我们需要告诉每个像素点颜色是什么，即将连续的模型变为离散的像素点，这就是光栅化。

当经过MVP变换后拥有三角形的三个顶点坐标后，如何判断每个像素的颜色？

![image-20230419223705502](/img/posts/2023-03-07-GAMES101/image-20230419223705502.png)

利用像素中心对屏幕空间进行采样，即判断每个像素中心是否在三角形内

![image-20230419223944136](/img/posts/2023-03-07-GAMES101/image-20230419223944136.png)

> 如何判断一个点是否在三角形内？
>

判断$\overrightarrow{QP_0} \times \overrightarrow{P_0P_1}, \overrightarrow{QP_1} \times \overrightarrow{P_1P_2}, \overrightarrow{QP_2} \times \overrightarrow{P_2P_0}$的符号，如果他们的符号都相同，那么这个点在三角形内，否则这个点在三角形外。

### 走样（aliasing)

![image-20230419230208498](/img/posts/2023-03-07-GAMES101/image-20230419230208498.png)

## 作业0

> 作业描述：给定一个点P=(2,1), 将该点绕原点先逆时针旋转45◦，再平移(1,2), 计算出
> 变换后点的坐标（要求用齐次坐标进行计算）。

```c++
#include<cmath>
#include<Eigen/Core>
#include<Eigen/Dense>
#include<iostream>


int main(){

    float pi = std::acos(-1);
    float alpha = 45.0f / 180.0 * pi;

    Eigen::Vector3f p(2.0f, 1.0f, 1.0f);
    Eigen::Matrix3f R;
    R << std::cos(alpha), -std::sin(alpha), 0.0, 
         std::sin(alpha), std::cos(alpha), 0.0, 
         0.0, 0.0, 1.0;
    Eigen::Matrix3f T;
    T << 1.0f, 0.0f, 1.0f,
         0.0f, 1.0f, 2.0f,
         0.0f, 0.0f, 1.0f;
    Eigen::Vector3f res = T * R * p;
    std::cout << res << std::endl;

    // result is 1.70711, 4.12132, 1
    return 0;
}
```

## 作业1

> 作业描述：实现旋转矩阵和透视投影矩阵以用光栅化算法实现一个三角形

```c++
/* main.cpp */
Eigen::Matrix4f get_model_matrix(float rotation_angle)
{
    Eigen::Matrix4f model = Eigen::Matrix4f::Identity();

    // Create the model matrix for rotating the triangle around the Z axis.
    // Then return it.

    model(0, 0) = cos(rotation_angle * 180 / MY_PI);
    model(0, 1) = -sin(rotation_angle * 180 / MY_PI);
    model(1, 0) = sin(rotation_angle * 180 / MY_PI);
    model(1, 1) = cos(rotation_angle * 180 / MY_PI);

    return model;
}

Eigen::Matrix4f get_projection_matrix(float eye_fov, float aspect_ratio,
                                      float zNear, float zFar)
{
    Eigen::Matrix4f projection = Eigen::Matrix4f::Identity();

    // Create the projection matrix for the given parameters.
    // Then return it.
    float top = tanf(eye_fov / 2.0f) * zNear;
    float bottom = -top;
    float right = top * aspect_ratio;
    float left = -right;

    projection(0, 0) = zNear / right;
    projection(1, 1) = zNear / top;
    projection(2, 2) = (zNear + zFar) / (zNear - zFar);
    projection(2, 3) = (2 * zNear * zFar) / (zNear - zFar);
    projection(3, 2) = -1.0f;
    return projection;
}
```

实现效果：

![image-20230419210907081](/img/posts/2023-03-07-GAMES101/image-20230419210907081.png)
